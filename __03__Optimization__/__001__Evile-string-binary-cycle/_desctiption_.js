// Давайте разберем код по строчкам:

function evilOptimized(n) {
  let count = 0; // Инициализируем переменную count для подсчета единичных битов
  while (n > 0) {
    // Пока число n больше 0, выполняем цикл
    count += n & 1; // Проверяем, является ли последний бит числа n единицей (используем побитовое И)
    // Если да, то увеличиваем count на 1
    n >>= 1; // Сдвигаем число n вправо на один бит (делим на 2)
  }
  return count & 1 ? "It's Odious!" : "It's Evil!"; // Проверяем, является ли count нечетным
  // Если да, то возвращаем "It's Odious!", иначе "It's Evil!"
}

// **Объяснение:**

// 1. **`function evilOptimized(n) {`** - объявляем функцию `evilOptimized`, которая принимает одно целое число `n` в качестве аргумента.
// 2. **`let count = 0;`** -  инициализируем переменную `count`, которая будет использоваться для подсчета количества единичных битов в двоичном представлении числа `n`.
// 3. **`while (n > 0) {`** -  начинаем цикл, который будет выполняться, пока значение `n` больше 0.
// 4. **`count += n & 1;`** -  внутри цикла:
//     * **`n & 1`**:  выполняется побитовое И (bitwise AND) между `n` и `1`.
//     * **Побитовое И** : эта операция проверяет, равен ли последний бит числа `n` единице. Если да, то результат `n & 1` будет равен 1, иначе 0.
//     * **`count += ...`**:  результат операции `n & 1` добавляется к счетчику `count`.
// 5. **`n >>= 1;`** -  сдвигаем число `n` вправо на один бит.  Это эквивалентно делению `n` на 2. Сдвиг вправо позволяет нам проверить следующий бит числа `n`.
// 6. **`return count & 1 ? "It's Odious!" : "It's Evil!";`** -  после завершения цикла, функция проверяет, является ли количество единичных битов (`count`) нечетным:
//     * **`count & 1`**:  с помощью побитового И проверяется, равен ли последний бит числа `count` единице.  Это эквивалентно проверке, является ли `count` нечетным.
//     * **`? "It's Odious!" : "It's Evil!"`**:  тернарный оператор (условное выражение). Если `count` нечетен (последний бит = 1), возвращается строка "It's Odious!", иначе - "It's Evil!".

// **По сути, эта функция определяет, является ли двоичное представление числа "злым" (Evil) или "отвратительным" (Odious) по определению:**

// * **"Злые" числа** имеют четное количество единичных битов.
// * **"Отвратительные" числа** имеют нечетное количество единичных битов.
